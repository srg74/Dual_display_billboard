// Web server
#include <TFT_eSPI.h>
#include <DNSServer.h>
#include <WiFi.h>
#include <AsyncTCP.h>
#include "ESPAsyncWebServer.h"
#include "ap-server.h"
#include <SPI.h>
#include <FS.h>
#include <LittleFS.h>
#include <TJpg_Decoder.h>
#include <set>
#include <vector>
#include <time.h>
#include <math.h>

struct TimeZoneOption {
  const char* name;
  const char* tz;
};

TimeZoneOption timeZones[] = {
  {"UTC", "UTC0"},
  {"Central Europe", "CET-1CEST,M3.5.0,M10.5.0/3"},
  {"UK", "GMT0BST,M3.5.0/1,M10.5.0"},
  {"US Eastern", "EST5EDT,M3.2.0/2,M11.1.0/2"},
  {"US Central", "CST6CDT,M3.2.0/2,M11.1.0/2"},
  {"US Mountain", "MST7MDT,M3.2.0/2,M11.1.0/2"},
  {"US Pacific", "PST8PDT,M3.2.0/2,M11.1.0/2"},
  {"Japan", "JST-9"},
  {"China", "CST-8"},
  {"India", "IST-5:30"},
  // Add more as needed
};
const int numTimeZones = sizeof(timeZones) / sizeof(timeZones[0]);
String currentTimeZone = "EST5EDT,M3.2.0/2,M11.1.0/2"; // Default

#define TFT_BACKLIGHT_PIN 22
#define firstScreenCS 5
#define secondScreenCS 15

TFT_eSPI tft = TFT_eSPI();

AsyncWebServer server(80);

// --- HTML form generator ---
String generateWiFiForm() {
  String options = "";
  for (auto& ssid : scannedSSIDs) {
    options += "<option value='" + ssid + "'>" + ssid + "</option>";
  }
  if (options == "") options = "<option>No networks found</option>";
  String form = "<h1>WiFi Setup</h1>"
                "<form action='/connect' method='POST'>"
                "SSID: <select name='ssid'>" + options + "</select><br>"
                "Password: <input type='password' name='password'><br>"
                "<input type='submit' value='Connect'>"
                "</form>"
                "<form action='/rescan' method='POST'><button type='submit'>Rescan</button></form>";
  return form;
}

// --- WiFi scan function ---
void scanWiFiNetworks() {
  scannedSSIDs.clear();
  int n = WiFi.scanNetworks();
  Serial.printf("Scanned %d networks\n", n);
  for (int i = 0; i < n; ++i) {
    String ssid = WiFi.SSID(i);
    scannedSSIDs.push_back(ssid);
    Serial.printf("  [%d] SSID: %s, RSSI: %d, Encryption: %s\n",
                  i + 1,
                  ssid.c_str(),
                  WiFi.RSSI(i),
                  WiFi.encryptionType(i) == WIFI_AUTH_OPEN ? "Open" : "Secured");
  }
}
void displayAnalogClockOnBothTFTs();
// Forward declarations for credential functions
bool loadWiFiCredentials(String& ssid, String& password);
void saveWiFiCredentials(const String& ssid, const String& password);

// Function prototypes
std::set<String> loadEnabledImages();
void saveEnabledImages(const std::set<String>& enabled);
void displayImageOnTFT(const String& path);
void setupTime();
void displayClockOnBothTFTs();
void displayAnalogClockOnBothTFTs(); 

// JPEG decoder callback for TFT
bool tft_output(int16_t x, int16_t y, uint16_t w, uint16_t h, uint16_t *bitmap) {
  if (y >= tft.height()) return 0;
  tft.pushImage(x, y, w, h, bitmap);
  return 1;
}

// Global variables
String storedSSID, storedPassword;
bool waitingForSTAConnect = false;
File uploadFile;

// --- Slideshow globals ---
std::vector<String> enabledImagesList;
size_t currentImageIndex = 0;
unsigned long lastImageSwitch = 0;
const unsigned long imageDisplayInterval = 10000; // 10 seconds per image

void refreshEnabledImagesList() {
  enabledImagesList.clear();
  std::set<String> enabled = loadEnabledImages();
  for (const auto& img : enabled) {
    if (LittleFS.exists(img)) {
      enabledImagesList.push_back(img);
    }
  }
  if (currentImageIndex >= enabledImagesList.size()) currentImageIndex = 0;
}

// --- Image horizontal scroll transition ---
void scrollImageHorizontally(const String& fromPath, const String& toPath, int steps = 5, int delayMs = 1) {
  Serial.printf("Scrolling (right to left) from %s to %s\n", fromPath.c_str(), toPath.c_str());
  int w = tft.width();
  int h = tft.height();
  for (int i = 0; i <= steps; ++i) {
    int offset = (w * i) / steps;

    // First display
    digitalWrite(firstScreenCS, LOW);
    if (LittleFS.exists(fromPath)) {
      TJpgDec.drawFsJpg(-offset, 0, fromPath, LittleFS);
    }
    if (LittleFS.exists(toPath)) {
      TJpgDec.drawFsJpg(w - offset, 0, toPath, LittleFS);
    }
    digitalWrite(firstScreenCS, HIGH);

    // Second display
    digitalWrite(secondScreenCS, LOW);
    if (LittleFS.exists(fromPath)) {
      TJpgDec.drawFsJpg(-offset, 0, fromPath, LittleFS);
    }
    if (LittleFS.exists(toPath)) {
      TJpgDec.drawFsJpg(w - offset, 0, toPath, LittleFS);
    }
    digitalWrite(secondScreenCS, HIGH);

    delay(delayMs);
  }
}

int backlightValue = 255; // 0-255

void setupBacklightPWM() {
  ledcAttachPin(TFT_BACKLIGHT_PIN, 1); // channel 1
  ledcSetup(1, 5000, 8); // channel 1, 5 KHz, 8-bit
  ledcWrite(1, backlightValue);
}

void setBacklight(uint8_t value) {
  backlightValue = value;
  ledcWrite(1, backlightValue);
  Serial.printf("Backlight set to: %d\n", backlightValue);
}

void setupTime() {
  setenv("TZ", currentTimeZone.c_str(), 1);
  tzset();

  // Map TZ string to human-readable name
  String tzName = "Unknown";
  if (currentTimeZone == "EST5EDT,M3.2.0/2,M11.1.0/2") tzName = "Eastern Standard Time";
  else if (currentTimeZone == "CET-1CEST,M3.5.0,M10.5.0/3") tzName = "Central European Time";
  else if (currentTimeZone == "UTC0") tzName = "UTC";
  else if (currentTimeZone == "GMT0BST,M3.5.0/1,M10.5.0") tzName = "UK Time";
  else if (currentTimeZone == "CST6CDT,M3.2.0/2,M11.1.0/2") tzName = "Central Standard Time";
  else if (currentTimeZone == "MST7MDT,M3.2.0/2,M11.1.0/2") tzName = "Mountain Standard Time";
  else if (currentTimeZone == "PST8PDT,M3.2.0/2,M11.1.0/2") tzName = "Pacific Standard Time";
  else if (currentTimeZone == "JST-9") tzName = "Japan Standard Time";
  else if (currentTimeZone == "CST-8") tzName = "China Standard Time";
  else if (currentTimeZone == "IST-5:30") tzName = "India Standard Time";

  time_t now = time(nullptr);
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);
  char buf[6];
  strftime(buf, sizeof(buf), "%H:%M", &timeinfo);

  Serial.printf("Local time %s, time zone - %s\n", buf, tzName.c_str());
}

void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.println("Booting...");

  setupBacklightPWM();

  if (!LittleFS.begin(true)) {
    Serial.println("LittleFS mount failed!");
    while (true);
  } else {
    Serial.println("LittleFS mounted successfully.");
  }

  pinMode(firstScreenCS, OUTPUT);
  digitalWrite(firstScreenCS, HIGH);
  pinMode(secondScreenCS, OUTPUT);
  digitalWrite(secondScreenCS, HIGH);

  digitalWrite(firstScreenCS, LOW);
  digitalWrite(secondScreenCS, LOW);
  tft.init();
  tft.setFreeFont(&FreeSans9pt7b);
  //tft.setTextSize(2);
  digitalWrite(firstScreenCS, HIGH);
  digitalWrite(secondScreenCS, HIGH);

  digitalWrite(firstScreenCS, LOW);
  tft.setRotation(3);
  tft.fillScreen(TFT_RED);
  digitalWrite(firstScreenCS, HIGH);

  digitalWrite(secondScreenCS, LOW);
  tft.setRotation(3);
  tft.fillScreen(TFT_BLACK);
  digitalWrite(secondScreenCS, HIGH);

  TJpgDec.setJpgScale(1);
  TJpgDec.setSwapBytes(true);
  TJpgDec.setCallback(tft_output);

  WiFi.mode(WIFI_STA);
  staModeSetMillis = millis();
  needScan = true;
  apStarted = false;

  if (loadWiFiCredentials(storedSSID, storedPassword) && storedSSID.length() > 0) {
    Serial.printf("Trying to connect to saved WiFi: %s\n", storedSSID.c_str());
    WiFi.mode(WIFI_STA);
    WiFi.begin(storedSSID.c_str(), storedPassword.c_str());
    wifiConnectStart = millis();
    waitingForSTAConnect = true;
    needScan = false;
  } else {
    WiFi.mode(WIFI_STA);
    staModeSetMillis = millis();
    needScan = true;
    apStarted = false;
  }

  // Register all server routes here
  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    if (wifiConnected) {
      std::set<String> enabled = loadEnabledImages();
      Serial.println("[Gallery] Enabled images:");
      for (const auto& e : enabled) Serial.println(e);

      String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <title>Billboard Controller</title>
  <style>
    body { background: #222; color: #fff; font-family: sans-serif; text-align: center; }
    .container { margin-top: 50px; }
    button, form { margin: 5px; }
    img { border: 1px solid #555; margin: 5px; }
    label { color: #fff; }
    .gallery-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 16px;
    }
    .gallery-item {
      background: #222;
      padding: 8px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .gallery-item.enabled {
      border: 3px solid #00ff00 !important;
      box-shadow: 0 0 16px #00ff00 !important;
      background: #112911 !important;
    }
  </style>
<script>
  function toggleImage(img, el) {
    var enabled = el.getAttribute('data-enabled') === '1' ? 0 : 1;
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/toggle", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.onload = function() {
      // Update the attribute and class before reload
      el.setAttribute('data-enabled', enabled);
      if (enabled) {
        el.parentElement.classList.add('enabled');
      } else {
        el.parentElement.classList.remove('enabled');
      }
      location.reload();
    };
    xhr.send("img=" + encodeURIComponent(img) + "&enabled=" + enabled);
  }
  function updateTime() {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", "/time", true);
    xhr.onload = function() {
      if (xhr.status == 200) {
        document.getElementById('currentTime').innerText = xhr.responseText;
      }
    };
    xhr.send();
  }
  setInterval(updateTime, 60000);
  window.onload = function() {
    updateTime();
    document.getElementById('uploadForm').onsubmit = function(e) {
      e.preventDefault();
      var formData = new FormData();
      var fileInput = document.getElementById('uploadInput');
      if (!fileInput.files.length) {
        alert("Please select a file.");
        return;
      }
      formData.append('upload', fileInput.files[0]);
      var xhr = new XMLHttpRequest();
      xhr.open('POST', '/upload', true);
      xhr.onload = function() {
        if (xhr.status == 200) {
          alert("Upload successful!");
          location.reload();
        } else {
          alert("Upload failed!");
        }
      };
      xhr.send(formData);
    };
  }
  function updateBrightness(val) {
    var percent = Math.round(val * 100 / 255);
    document.getElementById('brightnessValue').innerText = percent + "%";
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/set_brightness", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.send("value=" + val);
  }
  function changeTZ() {
    var sel = document.getElementById('tzSelect');
    var tz = sel.value;
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/set_timezone", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.onload = function() {
      if (xhr.status == 200) {
        setTimeout(function(){ location.reload(); }, 500);
      } else {
        alert("Failed to set time zone");
      }
    };
    xhr.send("tz=" + encodeURIComponent(tz));
  }
  function changeLabel() {
    var label = document.getElementById('clockLabelInput').value;
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/set_clock_label", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.onload = function() {
      if (xhr.status == 200) {
        setTimeout(function(){ location.reload(); }, 500);
      } else {
        alert("Failed to set clock label");
      }
    };
    xhr.send("label=" + encodeURIComponent(label));
  }
</script>
</head>
<body>
  <div class="container">
    <h1>Billboard Controller</h1>
    <p>ESP32 is connected to WiFi!</p>
)rawliteral";

      // Insert IP address as a normal string
      html += "<p>IP Address: <b>" + WiFi.localIP().toString() + "</b></p>";

      // Continue with the rest of the HTML using rawliteral
      html += R"rawliteral(
<p>Local time: <span id="currentTime">--:--:--</span></p>
<p>
  Time zone:
  <select id="tzSelect" onchange="changeTZ()">
)rawliteral";
      // Insert timezone options
      for (int i = 0; i < numTimeZones; ++i) {
        html += "<option value='" + String(timeZones[i].tz) + "'";
        if (currentTimeZone == timeZones[i].tz) html += " selected";
        html += ">" + String(timeZones[i].name) + "</option>";
      }
      html += R"rawliteral(
  </select>
</p>
    <form id="uploadForm" enctype="multipart/form-data">
      <input type="file" name="upload" id="uploadInput"><br><br>
      <input type="submit" value="Upload JPEG">
    </form>
    <div>
      <label for="brightnessSlider">Billboard brightness:</label>
      <input type="range" min="0" max="255" value="255" id="brightnessSlider" oninput="updateBrightness(this.value)">
      <span id="brightnessValue">100%</span>
    </div>
    <h2>Gallery</h2>
    <div class='gallery-row'>
)rawliteral";

      File root = LittleFS.open("/");
      File file = root.openNextFile();
      while (file) {
        String fname = file.name();
        if (fname.endsWith(".jpg") || fname.endsWith(".jpeg")) {
          bool isChecked = enabled.count(fname) > 0;
          html += "<div class='gallery-item";
          if (isChecked) html += " enabled";
          html += "'>";
          html += "<img src='" + fname + "' style='max-width:80px;max-height:80px;cursor:pointer;'";
          html += " onclick=\"toggleImage('" + fname + "', this)\"";
          html += " data-enabled='" + String(isChecked ? "1" : "0") + "'>";
          html += "<form method='POST' action='/delete' style='display:inline;'><input type='hidden' name='img' value='" + fname + "'><input type='submit' value='Delete'></form>";
          html += "</div>";
        }
        file = root.openNextFile();
      }
      html += R"rawliteral(
    </div>
    <br>
    <div>
      <label for="clockLabelInput">Clock label:</label>
      <input type="text" id="clockLabelInput" value="Munich">
      <button onclick="changeLabel()">Set Label</button>
    </div>
  </div>
</body>
</html>
)rawliteral";
      request->send(200, "text/html", html);
    } else {
      request->send(200, "text/html", generateWiFiForm());
    }
  });

  server.on("/rescan", HTTP_POST, [](AsyncWebServerRequest *request){
    WiFi.mode(WIFI_STA);
    scanWiFiNetworks();
    WiFi.mode(WIFI_AP_STA);
    request->redirect("/");
  });

  server.on("/connect", HTTP_POST, [](AsyncWebServerRequest *request){
    String ssid, password;
    if (request->hasParam("ssid", true)) {
      ssid = request->getParam("ssid", true)->value();
    }
    if (request->hasParam("password", true)) {
      password = request->getParam("password", true)->value();
    }
    lastTriedSSID = ssid;
    lastTriedPassword = password;
    wifiConnectStart = millis();
    WiFi.begin(ssid.c_str(), password.c_str());
    Serial.printf("Received new WiFi credentials: SSID=%s, PASSWORD=%s\n", ssid.c_str(), password.c_str());
    saveWiFiCredentials(ssid, password);
    request->redirect("/status");
  });

  server.on("/status", HTTP_GET, [](AsyncWebServerRequest *request){
    String html;
    wl_status_t status = WiFi.status();
    if (status == WL_CONNECTED) {
      html = "<h1>Connected!</h1><p>STA IP: " + WiFi.localIP().toString() + "</p><a href='/'>Go to Welcome</a>";
    } else if (wifiConnectStart > 0 && millis() - wifiConnectStart < 15000) {
      html = "<h1>Connecting...</h1><meta http-equiv='refresh' content='2'>";
    } else {
      html = "<h1>Connection failed!</h1><a href='/'>Try again</a>";
    }
    request->send(200, "text/html", html);
  });

  server.on("/upload", HTTP_POST, [](AsyncWebServerRequest *request){
    request->send(200, "text/plain", "OK");
  }, [](AsyncWebServerRequest *request, String filename, size_t index, uint8_t *data, size_t len, bool final){
    static String lastUploadedPath;
    if (!index) {
      String path = "/" + filename;
      Serial.printf("Raw filename: %s\n", filename.c_str());
      if (LittleFS.exists(path)) {
        path = "/" + String(millis()) + "_" + filename;
      }
      uploadFile = LittleFS.open(path, "w");
      Serial.printf("Upload path: %s\n", path.c_str());
      lastUploadedPath = path;
      Serial.printf("UploadStart: %s\n", path.c_str());
    }
    if (uploadFile) {
      uploadFile.write(data, len);
    }
    if (final && uploadFile) {
      uploadFile.close();
      Serial.printf("UploadEnd: %s\n", filename.c_str());
      std::set<String> enabled = loadEnabledImages();
      enabled.insert(lastUploadedPath);
      saveEnabledImages(enabled);
      refreshEnabledImagesList();
    }
  });

  server.on("/uploaded.jpg", HTTP_GET, [](AsyncWebServerRequest *request){
    if (LittleFS.exists("/uploaded.jpg")) {
      request->send(LittleFS, "/uploaded.jpg", "image/jpeg");
    } else {
      request->send(404, "text/plain", "No image uploaded.");
    }
  });

  server.on("/gallery", HTTP_GET, [](AsyncWebServerRequest *request){
    String galleryHtml = "<h2>Gallery</h2><div class='gallery-row'>";
    File root = LittleFS.open("/");
    File file = root.openNextFile();
    while (file) {
      String fname = file.name();
      if (fname.endsWith(".jpg") || fname.endsWith(".jpeg")) {
        galleryHtml += "<div class='gallery-item'><img src='" + fname + "' style='max-width:80px;max-height:80px;'><br>";
        galleryHtml += "<a href='/show?img=" + fname + "'>Show on Display</a></div>";
      }
      file = root.openNextFile();
    }
    galleryHtml += "</div>";
    request->send(200, "text/html", galleryHtml);
  });

  server.on("/show", HTTP_GET, [](AsyncWebServerRequest *request){
    if (request->hasParam("img")) {
      String img = request->getParam("img")->value();
      if (LittleFS.exists(img)) {
        digitalWrite(firstScreenCS, LOW);
        tft.fillScreen(TFT_BLACK);
        TJpgDec.drawFsJpg(0, 0, img, LittleFS);
        digitalWrite(firstScreenCS, HIGH);
        request->send(200, "text/html", "<h1>Displayed!</h1><a href='/'>Back</a>");
        return;
      }
    }
    request->send(404, "text/plain", "Image not found.");
  });

  server.on("/delete", HTTP_POST, [](AsyncWebServerRequest *request){
    if (request->hasParam("img", true)) {
      String img = request->getParam("img", true)->value();
      if (!img.startsWith("/")) img = "/" + img;
      Serial.println("Delete requested for: " + img);
      if (LittleFS.exists(img)) {
        LittleFS.remove(img);
        Serial.println("File deleted: " + img);
        std::set<String> enabled = loadEnabledImages();
        enabled.erase(img);
        saveEnabledImages(enabled);
        refreshEnabledImagesList();
      } else {
        Serial.println("File not found: " + img);
      }
    }
    request->redirect("/");
  });

  server.on("/toggle", HTTP_POST, [](AsyncWebServerRequest *request){
    if (request->hasParam("img", true) && request->hasParam("enabled", true)) {
      String img = request->getParam("img", true)->value();
      bool enable = request->getParam("enabled", true)->value() == "1";
      if (!img.startsWith("/")) img = "/" + img;
      Serial.printf("[/toggle] img=%s enable=%d\n", img.c_str(), enable);
      std::set<String> enabled = loadEnabledImages();
      if (enable) {
        enabled.insert(img);
        Serial.println("[/toggle] Added to enabled set.");
      } else {
        enabled.erase(img);
        Serial.println("[/toggle] Removed from enabled set.");
      }
      saveEnabledImages(enabled);
      refreshEnabledImagesList();
      Serial.println("[/toggle] Enabled set now:");
      for (const auto& e : enabled) Serial.println(e);
    } else {
      Serial.println("[/toggle] Missing parameters!");
    }
    request->send(200, "text/plain", "OK");
  });

  server.on("/set_brightness", HTTP_POST, [](AsyncWebServerRequest *request){
    if (request->hasParam("value", true)) {
      int val = request->getParam("value", true)->value().toInt();
      if (val < 0) val = 0;
      if (val > 255) val = 255;
      setBacklight(val);
      request->send(200, "text/plain", "OK");
    } else {
      request->send(400, "text/plain", "Missing value");
    }
  });

  server.on("/time", HTTP_GET, [](AsyncWebServerRequest *request){
    time_t now = time(nullptr);
    struct tm timeinfo;
    localtime_r(&now, &timeinfo);
    char buf[6];
    strftime(buf, sizeof(buf), "%H:%M", &timeinfo);
    request->send(200, "text/plain", buf);
  });

  server.on("/set_timezone", HTTP_POST, [](AsyncWebServerRequest *request){
    if (request->hasParam("tz", true)) {
      currentTimeZone = request->getParam("tz", true)->value();
      setenv("TZ", currentTimeZone.c_str(), 1);
      tzset();

      // Print human-readable time zone name and local time
      String tzName = "Unknown";
      if (currentTimeZone == "EST5EDT,M3.2.0/2,M11.1.0/2") tzName = "Eastern Standard Time";
      else if (currentTimeZone == "CET-1CEST,M3.5.0,M10.5.0/3") tzName = "Central European Time";
      else if (currentTimeZone == "UTC0") tzName = "UTC";
      else if (currentTimeZone == "GMT0BST,M3.5.0/1,M10.5.0") tzName = "UK Time";
      else if (currentTimeZone == "CST6CDT,M3.2.0/2,M11.1.0/2") tzName = "Central Standard Time";
      else if (currentTimeZone == "MST7MDT,M3.2.0/2,M11.1.0/2") tzName = "Mountain Standard Time";
      else if (currentTimeZone == "PST8PDT,M3.2.0/2,M11.1.0/2") tzName = "Pacific Standard Time";
      else if (currentTimeZone == "JST-9") tzName = "Japan Standard Time";
      else if (currentTimeZone == "CST-8") tzName = "China Standard Time";
      else if (currentTimeZone == "IST-5:30") tzName = "India Standard Time";

      time_t now = time(nullptr);
      struct tm timeinfo;
      localtime_r(&now, &timeinfo);
      char buf[6];
      strftime(buf, sizeof(buf), "%H:%M", &timeinfo);
      Serial.printf("Local time %s, time zone - %s\n", buf, tzName.c_str());

      request->send(200, "text/plain", "OK");
    } else {
      request->send(400, "text/plain", "Missing tz");
    }
  });

  server.on("/set_clock_label", HTTP_POST, [](AsyncWebServerRequest *request){
    if (request->hasParam("label", true)) {
      clockLabel = request->getParam("label", true)->value();
      clockLabel.trim();
      if (clockLabel.length() == 0) clockLabel = "Munich";
      // Optionally, save to LittleFS for persistence
    }
    request->redirect("/");
  });

  server.on("/favicon.ico", HTTP_GET, [](AsyncWebServerRequest *request){
    if (LittleFS.exists("/favicon.ico")) {
      request->send(LittleFS, "/favicon.ico", "image/x-icon");
    } else {
      request->send(404, "text/plain", "Not found");
    }
  });

  server.onNotFound([](AsyncWebServerRequest *request){
    String path = request->url();
    if ((path.endsWith(".jpg") || path.endsWith(".jpeg")) && LittleFS.exists(path)) {
      request->send(LittleFS, path, "image/jpeg");
    } else {
      request->send(404, "text/plain", "File not found");
    }
  });

  server.begin();
  Serial.println("Web server started.");

  refreshEnabledImagesList();
  if (enabledImagesList.empty()) {
    Serial.println("No images found in enabled list.");
  } else {
    Serial.printf("Enabled images: %d\n", enabledImagesList.size());
    for (const auto& img : enabledImagesList) {
      Serial.println(img);
    }
  }
}

void loop() {
  if (waitingForSTAConnect) {
    if (WiFi.status() == WL_CONNECTED) {
      wifiConnected = true;
      waitingForSTAConnect = false;
      Serial.println("Connected to WiFi from saved credentials!");
      digitalWrite(firstScreenCS, LOW);
      tft.setRotation(3);
      tft.fillScreen(TFT_GREEN);
      tft.setTextColor(TFT_BLACK, TFT_GREEN);
      tft.setFreeFont(&FreeSans9pt7b);
      tft.setCursor(30, 26);
      tft.printf("Connected!\nIP: %s", WiFi.localIP().toString().c_str());
      digitalWrite(firstScreenCS, HIGH);
      WiFi.softAPdisconnect(true);
      return;
    }
    // Timeout after 15 seconds
    if (millis() - wifiConnectStart > 15000) {
      Serial.println("WiFi connect timeout, falling back to AP mode.");
      waitingForSTAConnect = false;
      WiFi.disconnect(true);
      WiFi.mode(WIFI_STA);
      staModeSetMillis = millis();
      needScan = true;
      apStarted = false;
    }
    return;
  }

  // Non-blocking scan and AP start
  if (needScan && millis() - staModeSetMillis > 200) {
    scanWiFiNetworks();

    WiFi.mode(WIFI_AP_STA);
    IPAddress apIP(192,168,4,1);
    WiFi.softAPConfig(apIP, apIP, IPAddress(255,255,255,0));
    if (WiFi.softAP(ap_ssid, ap_password)) {
      Serial.println("AP started successfully.");
      Serial.print("AP IP address: ");
      Serial.println(WiFi.softAPIP());

      digitalWrite(firstScreenCS, LOW);
      tft.setRotation(3);
      tft.fillScreen(TFT_BLUE);
      tft.setTextColor(TFT_WHITE, TFT_BLUE);
      tft.setFreeFont(&FreeSans9pt7b);
      tft.setCursor(5, 26);
      tft.printf("AP started!\nSSID: %s\nIP: %s", ap_ssid, WiFi.softAPIP().toString().c_str());
      digitalWrite(firstScreenCS, HIGH);
    } else {
      Serial.println("AP start FAILED!");
      digitalWrite(firstScreenCS, LOW);
      tft.setRotation(3);
      tft.fillScreen(TFT_BLACK);
      tft.setTextColor(TFT_RED, TFT_BLACK);
      tft.setFreeFont(&FreeSans9pt7b);
      tft.setCursor(5, 26);
      tft.print("AP start FAILED!");
      digitalWrite(firstScreenCS, HIGH);
    }
    needScan = false;
  }

  // WiFi connection status debug
  if (!wifiConnected && WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println("Connected to local WiFi!");
    Serial.print("STA IP address: ");
    Serial.println(WiFi.localIP());

    digitalWrite(firstScreenCS, LOW);
    tft.setRotation(3);
    tft.fillScreen(TFT_GREEN);
    tft.setTextColor(TFT_BLACK, TFT_GREEN);
    tft.setFreeFont(&FreeSans9pt7b);
    tft.setCursor(5, 26);
    tft.printf("Connected!\nIP: %s", WiFi.localIP().toString().c_str());
    digitalWrite(firstScreenCS, HIGH);

    WiFi.softAPdisconnect(true);
    Serial.println("AP disabled after successful STA connection.");
  }

  // Start gallery timer if not started
  if (galleryStartTime == 0 && !enabledImagesList.empty()) {
    galleryStartTime = millis();
  }

  // After 30 seconds, show clock for 5 seconds
  if (!showClock && galleryStartTime > 0 && millis() - galleryStartTime > 30000) {
    showClock = true;
    clockDisplayStart = millis();
    // Draw analog clock immediately
    displayAnalogClockOnBothTFTs(); // <-- This causes the issue!
  }

  // After clock display duration, resume gallery
  if (showClock && millis() - clockDisplayStart > clockDisplayDuration) {
    showClock = false;
    galleryStartTime = millis(); // restart gallery timer
    lastImageSwitch = millis();  // resume image cycling
    // Optionally, redraw the current gallery image
    if (!enabledImagesList.empty()) {
      displayImageOnTFT(enabledImagesList[currentImageIndex]);
    }
  }

  // Only run gallery if not showing clock
  if (!showClock) {
    static String prevImagePath = "";
    if (!enabledImagesList.empty() && millis() - lastImageSwitch > imageDisplayInterval) {
      String newPath = enabledImagesList[currentImageIndex];
      if (prevImagePath != "" && prevImagePath != newPath) {
        scrollImageHorizontally(prevImagePath, newPath);
      } else {
        displayImageOnTFT(newPath);
      }
      prevImagePath = newPath;
      currentImageIndex = (currentImageIndex + 1) % enabledImagesList.size();
      lastImageSwitch = millis();
    }
  }

  // Only call setupTime() once after WiFi connects
  if (wifiConnected && !timeInitialized) {
    configTime(0, 0, "pool.ntp.org", "time.nist.gov");
    setupTime();
    timeInitialized = true;
  }
}

// Save WiFi credentials to LittleFS
void saveWiFiCredentials(const String& ssid, const String& password) {
  File file = LittleFS.open("/wifi.txt", "w");
  if (file) {
    file.println(ssid);
    file.println(password);
    file.close();
    Serial.println("WiFi credentials saved to LittleFS.");
  } else {
    Serial.println("Failed to open file for writing.");
  }
}

// Load WiFi credentials from LittleFS
bool loadWiFiCredentials(String& ssid, String& password) {
  File file = LittleFS.open("/wifi.txt", "r");
  if (file) {
    ssid = file.readStringUntil('\n'); ssid.trim();
    password = file.readStringUntil('\n'); password.trim();
    file.close();
    Serial.println("WiFi credentials loaded from LittleFS.");
    return true;
  }
  return false;
}

// Helper to load enabled images
std::set<String> loadEnabledImages() {
  std::set<String> enabled;
  if (!LittleFS.exists("/enabled.txt")) {
    // Create an empty file so the warning goes away
    File f = LittleFS.open("/enabled.txt", "w");
    if (f) f.close();
    return enabled;
  }
  File f = LittleFS.open("/enabled.txt", "r");
  while (f && f.available()) {
    String line = f.readStringUntil('\n');
    line.trim();
    if (line.length()) enabled.insert(line);
  }
  if (f) f.close();
  return enabled;
}

// Helper to save enabled images
void saveEnabledImages(const std::set<String>& enabled) {
  File f = LittleFS.open("/enabled.txt", "w");
  for (const auto& name : enabled) {
    f.println(name);
  }
  if (f) f.close();
}

void displayImageOnTFT(const String& path) {
  if (LittleFS.exists(path)) {
    // First display
    digitalWrite(firstScreenCS, LOW);
    tft.fillScreen(TFT_BLACK);
    tft.setRotation(0); // 90 deg CW
    TJpgDec.drawFsJpg(0, 0, path, LittleFS);
    digitalWrite(firstScreenCS, HIGH);

    // Second display
    digitalWrite(secondScreenCS, LOW);
    tft.fillScreen(TFT_BLACK);
    tft.setRotation(0); // 90 deg CW
    TJpgDec.drawFsJpg(0, 0, path, LittleFS);
    digitalWrite(secondScreenCS, HIGH);

    Serial.println("Displayed on both TFTs: " + path);
  }
}

void displayAnalogClockOnBothTFTs() {
  time_t now = time(nullptr);
  struct tm timeinfo;
  localtime_r(&now, &timeinfo);

  // Clock parameters
  int centerX = 40; // Adjust for your display size (80x160 typical for ST7735)
  int centerY = 80;
  int radius = 39;

  auto drawClock = [&](int csPin) {
    digitalWrite(csPin, LOW);
    tft.setRotation(0); // 90 deg CW
    tft.fillScreen(TFT_BLACK);

    // Draw "Munich" above the clock
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextFont(2); // Medium font, adjust as needed
    int textWidth = tft.textWidth(clockLabel.c_str());
    tft.setCursor(centerX - textWidth / 2, 18);
    tft.print(clockLabel);

    // Draw clock face
    tft.drawCircle(centerX, centerY, radius, TFT_SKYBLUE);
    tft.drawCircle(centerX, centerY, 2, TFT_WHITE); // center dot

    // Draw hour marks
    for (int h = 0; h < 12; h++) {
      float angle = (h * 30 - 90) * DEG_TO_RAD;
      int x0 = centerX + cos(angle) * (radius - 8);
      int y0 = centerY + sin(angle) * (radius - 8);
      int x1 = centerX + cos(angle) * (radius - 2);
      int y1 = centerY + sin(angle) * (radius - 2);
      tft.drawLine(x0, y0, x1, y1, TFT_WHITE);
    }

    // Calculate angles for hands
    float minAngle = (timeinfo.tm_min * 6 + timeinfo.tm_sec * 0.1 - 90) * DEG_TO_RAD;
    float hourAngle = ((timeinfo.tm_hour % 12) * 30 + timeinfo.tm_min * 0.5 - 90) * DEG_TO_RAD;

    // Draw hour hand
    int hx = centerX + cos(hourAngle) * (radius * 0.5);
    int hy = centerY + sin(hourAngle) * (radius * 0.5);
    tft.drawLine(centerX, centerY, hx, hy, TFT_RED);

    // Draw minute hand
    int mx = centerX + cos(minAngle) * (radius * 0.8);
    int my = centerY + sin(minAngle) * (radius * 0.8);
    tft.drawLine(centerX, centerY, mx, my, TFT_RED);

    tft.setRotation(3); // Restore gallery rotation
    digitalWrite(csPin, HIGH);
  };

  drawClock(firstScreenCS);
  drawClock(secondScreenCS);
}

void saveClockLabel(const String& label) {
  File f = LittleFS.open("/clocklabel.txt", "w");
  if (f) {
    f.println(label);
    f.close();
  }
}

String loadClockLabel() {
  File f = LittleFS.open("/clocklabel.txt", "r");
  if (f) {
    String label = f.readStringUntil('\n');
    label.trim();
    f.close();
    if (label.length() > 0) return label;
  }
  return "Munich"; // Default
}
